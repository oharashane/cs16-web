<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>TURBO Client Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .success { background: #d4edda; border-color: #c3e6cb; }
        .error { background: #f8d7da; border-color: #f5c6cb; }
        .info { background: #d1ecf1; border-color: #bee5eb; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        #canvas { border: 2px solid #333; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>ðŸš€ TURBO Client Test</h1>
    
    <div class="test-section info">
        <h3>Test Parameters</h3>
        <p>This page tests the TURBO client functionality with different URL parameters.</p>
        <p>Current URL: <code id="currentUrl"></code></p>
    </div>
    
    <div class="test-section">
        <h3>WebGL 3D Rendering Test</h3>
        <div style="position: relative; display: inline-block;">
            <canvas id="game" width="800" height="600"></canvas>
            <div id="fpsCounter" style="
                position: absolute; 
                top: 10px; 
                left: 10px; 
                background: rgba(0,0,0,0.7); 
                color: #4CAF50; 
                padding: 5px 10px; 
                border-radius: 5px; 
                font-family: monospace; 
                font-weight: bold;
                z-index: 1000;
            ">FPS: --</div>
        </div>
        <div>
            <button onclick="testCanvasResize()">Test Canvas Resize</button>
            <button onclick="testTurboMode()">Test TURBO Mode</button>
            <button onclick="toggleWebGL()">Toggle WebGL</button>
        </div>
        <div id="canvasInfo"></div>
    </div>
    
    <div class="test-section">
        <h3>URL Parameter Tests</h3>
        <p>Test different TURBO configurations:</p>
        <button onclick="testUrl('?scale=0.5&maxdpr=1')">Half Resolution + DPR Clamp</button>
        <button onclick="testUrl('?scale=0.75&maxdpr=1')">75% Resolution + DPR Clamp</button>
        <button onclick="testUrl('?scale=1.0&maxdpr=0')">Full Resolution + No DPR Limit</button>
        <button onclick="testUrl('?scale=0.25&maxdpr=1')">Ultra Low Resolution</button>
    </div>
    
    <div class="test-section">
        <h3>Performance Info</h3>
        <div id="perfInfo"></div>
    </div>

    <script>
        // Display current URL
        document.getElementById('currentUrl').textContent = window.location.href;
        
        // Get URL parameters
        const params = new URL(location.href).searchParams;
        const SCALE = Math.max(0.25, Math.min(1, parseFloat(params.get('scale') || '1')));
        const MAX_DPR = parseFloat(params.get('maxdpr') || '0');
        
        // Update performance info
        function updatePerfInfo() {
            const dpr = window.devicePixelRatio || 1;
            const effectiveDpr = (MAX_DPR > 0 ? Math.min(dpr, MAX_DPR) : dpr) * SCALE;
            
            document.getElementById('perfInfo').innerHTML = `
                <p><strong>Scale:</strong> ${SCALE}</p>
                <p><strong>Max DPR:</strong> ${MAX_DPR === 0 ? 'No Limit' : MAX_DPR}</p>
                <p><strong>Device DPR:</strong> ${dpr}</p>
                <p><strong>Effective DPR:</strong> ${effectiveDpr.toFixed(2)}</p>
                <p><strong>Canvas CSS Size:</strong> <span id="cssSize">-</span></p>
                <p><strong>Canvas Render Size:</strong> <span id="renderSize">-</span></p>
            `;
        }
        
        // Test canvas resize functionality
        function testCanvasResize() {
            const canvas = document.getElementById('game');
            const cssW = 800;
            const cssH = 600;
            
            // Set CSS size
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
            
            // Calculate render size
            const dpr = window.devicePixelRatio || 1;
            const effectiveDpr = (MAX_DPR > 0 ? Math.min(dpr, MAX_DPR) : dpr) * SCALE;
            const w = Math.max(1, Math.floor(cssW * effectiveDpr));
            const h = Math.max(1, Math.floor(cssH * effectiveDpr));
            
            // Set backing store size
            canvas.width = w;
            canvas.height = h;
            
            // Update info
            document.getElementById('cssSize').textContent = `${cssW} Ã— ${cssH}`;
            document.getElementById('renderSize').textContent = `${w} Ã— ${h}`;
            
            // Draw something on the canvas
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff6b35';
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`TURBO MODE: ${w}Ã—${h}`, w/2, h/2);
            ctx.fillText(`Scale: ${SCALE}, DPR: ${effectiveDpr.toFixed(2)}`, w/2, h/2 + 30);
            
            console.log(`Canvas resized: CSS=${cssW}Ã—${cssH}, Render=${w}Ã—${h}, DPR=${effectiveDpr}`);
        }
        
        // Test TURBO mode
        function testTurboMode() {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            
            // Simulate TURBO mode canvas management
            const cssW = window.innerWidth * 0.8;
            const cssH = window.innerHeight * 0.6;
            
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
            
            const dpr = window.devicePixelRatio || 1;
            const effectiveDpr = (MAX_DPR > 0 ? Math.min(dpr, MAX_DPR) : dpr) * SCALE;
            const w = Math.max(1, Math.floor(cssW * effectiveDpr));
            const h = Math.max(1, Math.floor(cssH * effectiveDpr));
            
            canvas.width = w;
            canvas.height = h;
            
            // Draw TURBO mode indicator
            ctx.fillStyle = '#ff6b35';
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ðŸš€ TURBO MODE ACTIVE', w/2, h/2 - 20);
            ctx.fillText(`CSS: ${Math.floor(cssW)}Ã—${Math.floor(cssH)}`, w/2, h/2 + 10);
            ctx.fillText(`Render: ${w}Ã—${h}`, w/2, h/2 + 35);
            ctx.fillText(`Scale: ${SCALE}, DPR: ${effectiveDpr.toFixed(2)}`, w/2, h/2 + 60);
            
            document.getElementById('cssSize').textContent = `${Math.floor(cssW)} Ã— ${Math.floor(cssH)}`;
            document.getElementById('renderSize').textContent = `${w} Ã— ${h}`;
        }
        
        // Test different URL configurations
        function testUrl(params) {
            const newUrl = window.location.pathname + params;
            window.location.href = newUrl;
        }
        
        // WebGL 3D Rendering Functions
        function initWebGL() {
            const canvas = document.getElementById('game');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                console.error('WebGL not supported');
                return false;
            }
            
            // Create shaders
            const vertexShader = createShader(gl.VERTEX_SHADER, `
                attribute vec3 a_position;
                attribute vec3 a_color;
                uniform mat4 u_modelViewMatrix;
                uniform mat4 u_projectionMatrix;
                varying vec3 v_color;
                
                void main() {
                    gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_position, 1.0);
                    v_color = a_color;
                }
            `);
            
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, `
                precision mediump float;
                varying vec3 v_color;
                
                void main() {
                    gl_FragColor = vec4(v_color, 1.0);
                }
            `);
            
            // Create program
            program = createProgram(vertexShader, fragmentShader);
            
            // Create complex 3D geometry (multiple cubes with different colors)
            const vertices = [];
            const indices = [];
            let vertexIndex = 0;
            
            // Generate multiple cubes in a grid pattern
            for (let x = -2; x <= 2; x += 1) {
                for (let y = -2; y <= 2; y += 1) {
                    for (let z = -2; z <= 2; z += 1) {
                        const offsetX = x * 2.5;
                        const offsetY = y * 2.5;
                        const offsetZ = z * 2.5;
                        const color = [
                            (x + 2) / 4,
                            (y + 2) / 4,
                            (z + 2) / 4
                        ];
                        
                        // Cube vertices (8 vertices per cube)
                        const cubeVertices = [
                            // Front face
                            [-0.5 + offsetX, -0.5 + offsetY,  0.5 + offsetZ, ...color],
                            [ 0.5 + offsetX, -0.5 + offsetY,  0.5 + offsetZ, ...color],
                            [ 0.5 + offsetX,  0.5 + offsetY,  0.5 + offsetZ, ...color],
                            [-0.5 + offsetX,  0.5 + offsetY,  0.5 + offsetZ, ...color],
                            // Back face
                            [-0.5 + offsetX, -0.5 + offsetY, -0.5 + offsetZ, ...color],
                            [ 0.5 + offsetX, -0.5 + offsetY, -0.5 + offsetZ, ...color],
                            [ 0.5 + offsetX,  0.5 + offsetY, -0.5 + offsetZ, ...color],
                            [-0.5 + offsetX,  0.5 + offsetY, -0.5 + offsetZ, ...color]
                        ];
                        
                        vertices.push(...cubeVertices.flat());
                        
                        // Cube indices (12 triangles per cube)
                        const cubeIndices = [
                            0, 1, 2, 0, 2, 3,  // Front
                            1, 5, 6, 1, 6, 2,  // Right
                            5, 4, 7, 5, 7, 6,  // Back
                            4, 0, 3, 4, 3, 7,  // Left
                            3, 2, 6, 3, 6, 7,  // Top
                            4, 5, 1, 4, 1, 0   // Bottom
                        ];
                        
                        indices.push(...cubeIndices.map(i => i + vertexIndex));
                        vertexIndex += 8;
                    }
                }
            }
            
            // Create buffers
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            // Set up attributes
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            const colorLocation = gl.getAttribLocation(program, 'a_color');
            
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 24, 0);
            
            gl.enableVertexAttribArray(colorLocation);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 24, 12);
            
            // Set up viewport
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Enable depth testing
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            
            console.log('WebGL initialized with', vertices.length / 6, 'vertices and', indices.length / 3, 'triangles');
            return true;
        }
        
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        function createProgram(vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
        
        function renderWebGL(currentTime) {
            if (!webglActive || !gl || !program) return;
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
            }
            
            // Clear
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Use program
            gl.useProgram(program);
            
            // Set matrices
            const projectionMatrix = createProjectionMatrix();
            const modelViewMatrix = createModelViewMatrix();
            
            const projectionLocation = gl.getUniformLocation(program, 'u_projectionMatrix');
            const modelViewLocation = gl.getUniformLocation(program, 'u_modelViewMatrix');
            
            gl.uniformMatrix4fv(projectionLocation, false, projectionMatrix);
            gl.uniformMatrix4fv(modelViewLocation, false, modelViewMatrix);
            
            // Draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, 125 * 36, gl.UNSIGNED_SHORT, 0); // 125 cubes * 36 indices
            
            // Update rotation
            rotation += 0.01;
            
            // Continue animation
            animationId = requestAnimationFrame(renderWebGL);
        }
        
        function createProjectionMatrix() {
            const fieldOfView = 45 * Math.PI / 180;
            const aspect = 800 / 600;
            const zNear = 0.1;
            const zFar = 100.0;
            
            const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfView);
            const rangeInv = 1.0 / (zNear - zFar);
            
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (zNear + zFar) * rangeInv, -1,
                0, 0, zNear * zFar * rangeInv * 2, 0
            ];
        }
        
        function createModelViewMatrix() {
            const translation = [0, 0, -20];
            const rotationX = rotation * 0.5;
            const rotationY = rotation;
            
            // Translation
            const tx = translation[0];
            const ty = translation[1];
            const tz = translation[2];
            
            // Rotation matrices
            const cosX = Math.cos(rotationX);
            const sinX = Math.sin(rotationX);
            const cosY = Math.cos(rotationY);
            const sinY = Math.sin(rotationY);
            
            return [
                cosY, sinX * sinY, cosX * sinY, 0,
                0, cosX, -sinX, 0,
                -sinY, sinX * cosY, cosX * cosY, 0,
                tx, ty, tz, 1
            ];
        }
        
        function toggleWebGL() {
            if (webglActive) {
                stopWebGL();
            } else {
                startWebGL();
            }
        }
        
        function startWebGL() {
            if (initWebGL()) {
                webglActive = true;
                lastTime = performance.now();
                frameCount = 0;
                renderWebGL(performance.now());
                console.log('WebGL rendering started');
            }
        }
        
        function stopWebGL() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            webglActive = false;
            console.log('WebGL rendering stopped');
        }
        
        // WebGL 3D Rendering Variables
        let gl = null;
        let program = null;
        let vertexBuffer = null;
        let indexBuffer = null;
        let rotation = 0;
        let animationId = null;
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        let webglActive = false;
        
        // Initialize
        updatePerfInfo();
        testCanvasResize();
        
        // Log TURBO mode initialization
        console.log(`ðŸš€ TURBO MODE test initialized with scale=${SCALE}, maxdpr=${MAX_DPR}`);
        console.log(`Device pixel ratio: ${window.devicePixelRatio || 1}`);
    </script>
</body>
</html>
