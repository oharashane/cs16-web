<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="icon" href="/assets/favicon.png" type="image/png">
  <title>CS 1.6 Web Client (TURBO MODE)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  
  <!-- ðŸš€ TURBO MODE: Conservative Property Trap Solution -->
  <script>
  (() => {
    // --- Config via cookies ---
    function getCookie(name) {
      const nameEQ = name + "=";
      const ca = document.cookie.split(';');
      for(let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    }
    
    const SCALE = Math.max(0.25, Math.min(1, parseFloat(getCookie('turbo_scale') || '0.75')));
    const MAXDPR = parseFloat(getCookie('turbo_maxdpr') || '1');
    const realDPR = window.devicePixelRatio || 1;
    const clampedDPR = (MAXDPR > 0 ? Math.min(realDPR, MAXDPR) : realDPR);
    const effectiveScale = clampedDPR * SCALE;
    
    console.log(`ðŸš€ TURBO MODE: Scale=${SCALE}, MaxDPR=${MAXDPR}, EffectiveScale=${effectiveScale}`);
    console.log(`ðŸš€ TURBO MODE: Real DPR=${realDPR}, Clamped DPR=${clampedDPR}`);

    // Conservative DPR override (only if allowed)
    try {
      Object.defineProperty(window, 'devicePixelRatio', {
        get: () => clampedDPR,
        configurable: true
      });
      console.log('ðŸš€ TURBO MODE: Successfully overrode devicePixelRatio');
    } catch (e) { 
      console.log('ðŸš€ TURBO MODE: Could not override devicePixelRatio (harmless)');
    }

    // Simple canvas size scaling without aggressive property traps
    let originalCanvasSize = null;
    
    function scaleCanvas(canvas) {
      if (!canvas) return;
      
      // Get the current canvas size (what the engine set)
      const currentWidth = canvas.width || 800;
      const currentHeight = canvas.height || 600;
      
      // If we haven't stored the original size yet, store it
      if (!originalCanvasSize) {
        originalCanvasSize = { width: currentWidth, height: currentHeight };
        console.log(`ðŸš€ TURBO MODE: Original canvas size: ${currentWidth}Ã—${currentHeight}`);
      }
      
      // Only scale if we haven't scaled this canvas yet
      if (canvas.__turboScaled) {
        return;
      }
      
      // Calculate scaled backing store size based on original size
      const scaledWidth = Math.max(1, Math.floor(originalCanvasSize.width * effectiveScale));
      const scaledHeight = Math.max(1, Math.floor(originalCanvasSize.height * effectiveScale));
      
      // Store the original CSS size that the engine intended
      const intendedCSSWidth = canvas.style.width || '100vw';
      const intendedCSSHeight = canvas.style.height || '100vh';
      
      // Scale the backing store (render resolution)
      canvas.width = scaledWidth;
      canvas.height = scaledHeight;
      
      // Keep the CSS size as the engine intended (full viewport)
      canvas.style.width = intendedCSSWidth;
      canvas.style.height = intendedCSSHeight;
      
      // Mark this canvas as scaled to prevent re-scaling
      canvas.__turboScaled = true;
      
      console.log(`ðŸš€ TURBO MODE: Scaled backing store to ${scaledWidth}Ã—${scaledHeight} (CSS: ${intendedCSSWidth}Ã—${intendedCSSHeight})`);
    }

    // WebGL context optimization
    function optimizeWebGLContext(canvas) {
      if (!canvas) return;
      
      const origGetContext = canvas.getContext;
      canvas.getContext = function(type, attrs) {
        if (type === 'webgl' || type === 'webgl2' || type === 'experimental-webgl') {
          attrs = Object.assign({
            antialias: false,
            alpha: false,
            depth: true,
            stencil: false,
            preserveDrawingBuffer: false,
            desynchronized: true,
            powerPreference: 'high-performance'
          }, attrs || {});
          console.log('ðŸš€ TURBO MODE: WebGL context created with optimized attributes');
        }
        return origGetContext.call(this, type, attrs);
      };
      console.log('ðŸš€ TURBO MODE: getContext optimized');
    }

    // Server parameter handling
    function getServerPort() {
      const urlParams = new URL(location.href).searchParams;
      const serverPort = urlParams.get('server');
      const port = parseInt(serverPort);
      
      if (port >= 27000 && port <= 27030) {
        return port;
      }
      
      console.warn('Invalid or missing server parameter:', serverPort);
      return null;
    }
    
    window.CS16_SERVER_PORT = getServerPort();
    console.log('CS16 Server Port (from ?server= parameter):', window.CS16_SERVER_PORT || 'unknown');

    // Configure Module with conservative settings
    window.Module = window.Module || {};
    
    // Set up canvas reference
    Module.canvas = (() => {
      let cached = null;
      return new Proxy({}, {
        get(_, prop) {
          if (!cached) {
            cached = document.getElementById('canvas');
            if (cached) {
              optimizeWebGLContext(cached);
              scaleCanvas(cached);
            }
          }
          return cached ? (cached[prop].bind ? cached[prop].bind(cached) : cached[prop]) : undefined;
        },
        set(_, prop, val) {
          const c = document.getElementById('canvas');
          if (c) c[prop] = val;
          return true;
        }
      });
    })();

    // WebGL context attributes
    Module.webglContextAttributes = Object.assign(
      {
        antialias: false,
        alpha: false,
        depth: true,
        stencil: false,
        preserveDrawingBuffer: false,
        powerPreference: 'high-performance'
      },
      Module.webglContextAttributes || {}
    );

    // WASM memory configuration
    Module.INITIAL_MEMORY = 536870912;  // 512MB
    Module.ALLOW_MEMORY_GROWTH = 0;     // Disable memory growth

    // Conservative scaling after engine loads
    Module.preRun = Module.preRun || [];
    Module.preRun.push(function () {
      console.log('ðŸš€ TURBO MODE: Engine preRun - applying conservative scaling');
      
      // Wait a bit for engine to settle, then apply scaling
      setTimeout(() => {
        const canvas = document.getElementById('canvas');
        if (canvas) {
          scaleCanvas(canvas);
          console.log('ðŸš€ TURBO MODE: Applied scaling after engine initialization');
        }
      }, 1000);
    });

    // Monitor for canvas changes (conservative approach)
    let lastCanvasSize = { width: 0, height: 0 };
    
    function checkCanvasSize() {
      const canvas = document.getElementById('canvas');
      if (canvas && !canvas.__turboScaled && (canvas.width !== lastCanvasSize.width || canvas.height !== lastCanvasSize.height)) {
        lastCanvasSize = { width: canvas.width, height: canvas.height };
        scaleCanvas(canvas);
      }
    }

    // Periodic check for canvas size changes (less aggressive than MutationObserver)
    setInterval(checkCanvasSize, 2000);

    console.log('ðŸš€ TURBO MODE: Conservative property trap solution initialized');
  })();
  </script>

  <style>
    html, body { 
      margin: 0; 
      height: 100%; 
      background: #000; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    #canvas { 
      width: 100vw; 
      height: 100vh; 
      display: block; 
      position: fixed;
      top: 0;
      left: 0;
      /* TURBO MODE: nearest-neighbor upscale for pixelated look */
      image-rendering: pixelated; 
      image-rendering: crisp-edges; 
    }
    
    /* Game-specific styles from index.html */
    .notDraggable {
        user-select: none;
        -webkit-user-drag: none;
        pointer-events: none;
    }

    @keyframes pulsate {
        0% {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        100% {
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 0.75;
        }
    }

    @keyframes pulsate-end {
        0% {
            transform: translate(-50%, -50%) scale(0.75);
            opacity: 0.87;
        }
        100% {
            transform: translate(-50%, -50%) scale(1);
            opacity: 0;
        }
    }

    img {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-width: 100vw;
        max-height: 100vh;
        animation-name: pulsate;
        animation-duration: 0.75s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
        z-index: 2;
        transition: opacity ease-in-out 0.5s;
    }

    canvas {
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
    }

    form {
        margin: 0;
        padding: 16px;
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 2;
        display: flex;
        justify-content: space-between;
        color: white;
    }

    #warning {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 3;
        text-align: center;
        color: red;
        opacity: 0;
        transition: opacity ease-in-out 0.5s;
    }
  </style>
</head>

<body>
  <!-- Loading image (same as index.html) -->
  <img id="logo" alt="Loading..." class="notDraggable" src="/assets/loading.jpg"/>

  <!-- Canvas for the game (will be managed by the property traps) -->
  <canvas id="canvas"></canvas>

  <!-- Player name form (same as index.html) -->
  <form id="form">
    <label>
        Player name
        <input id="username" type="text" required/>
    </label>
    <button type="submit">
        GO
    </button>
  </form>
  
  <!-- Warning message (same as index.html) -->
  <p id="warning" class="notDraggable">If it's not starting, try to enable microphone and refresh</p>

  <!-- Your existing script loader below (the compiled main.js from yohimik's build). -->
  <script type="module" crossorigin src="/assets/main-CqZe0kYo.js"></script>
</body>
</html>
